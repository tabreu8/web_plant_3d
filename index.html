<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>3D Industrial Plant Simulator</title>
    <style>
        :root {
            --bg: #0f1220;
            --panel: #161a2e;
            --muted: #8aa0b6;
            --accent: #35b9ff;
            --danger: #ff4d4f;
            --ok: #57d38c;
            --sidebar: 340px;
        }

        * {
            box-sizing: border-box;
        }

        html,
        body {
            height: 100%;
            margin: 0;
            background: var(--bg);
            color: #e8f1ff;
            font-family: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
        }

        #app {
            display: grid;
            grid-template-columns: var(--sidebar) 6px 1fr;
            grid-template-rows: 52px 1fr;
            grid-template-areas: 'top top top' 'left split main';
            height: 100%;
        }

        header {
            grid-area: top;
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 12px;
            background: var(--panel);
            border-bottom: 1px solid #212649;
        }

        header h1 {
            font-size: 16px;
            margin: 0;
            opacity: .95;
        }

        .conn {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .sidebar-toggle {
            display: none;
            background: var(--accent);
            color: white;
            border: 1px solid var(--accent);
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .pill {
            padding: 4px 8px;
            border-radius: 999px;
            font-size: 12px;
            border: 1px solid #2b315c;
            color: var(--muted);
        }

        .pill.ok {
            color: var(--ok);
            border-color: #2e5644;
        }

        .pill.bad {
            color: var(--danger);
            border-color: #5a2a2b;
        }

        aside {
            grid-area: left;
            background: var(--panel);
            border-right: 1px solid #212649;
            min-width: 240px;
            padding: 12px;
            overflow: auto;
        }

        .splitter {
            grid-area: split;
            cursor: col-resize;
            background: linear-gradient(to right, transparent 0, #1e2347 40%, #1e2347 60%, transparent 100%);
            position: relative;
        }

        .splitter::after {
            content: '';
            position: absolute;
            inset: 0;
            background:
                radial-gradient(circle at 50% 30%, #2b315c 2px, transparent 3px),
                radial-gradient(circle at 50% 50%, #2b315c 2px, transparent 3px),
                radial-gradient(circle at 50% 70%, #2b315c 2px, transparent 3px);
            background-repeat: no-repeat;
            background-position: center;
        }


        main {
            grid-area: main;
            position: relative;
            overflow: hidden;
        }

        #scene {
            position: absolute;
            inset: 0;
        }

        .section {
            margin: 10px 0 14px;
            border: 1px solid #2b315c;
            border-radius: 8px;
            background: #0f1326;
            overflow: hidden;
            box-shadow: 0 1px 0 rgba(0, 0, 0, 0.15);
        }

        .section h3 {
            margin: 0;
            padding: 10px 12px;
            font-size: 13px;
            font-weight: 700;
            letter-spacing: .02em;
            cursor: pointer;
            user-select: none;
            color: #cfe2ff;
            background: linear-gradient(180deg, #131a3a, #0f142f);
            border-bottom: 1px solid #2b315c;
            position: relative;
        }

        .section h3::before {
            content: '\25BC';
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%) rotate(0deg);
            font-size: 11px;
            color: #9db6ff;
            transition: transform .15s ease;
        }

        .section.collapsed h3::before {
            transform: translateY(-50%) rotate(-90deg);
        }

        .section h3:hover {
            background: #101736;
        }

        .section-body {
            padding: 10px 12px;
        }

        .section.collapsed .section-body {
            display: none;
        }

        /* Also support sections without explicit section-body wrapper */
        .section.collapsed>*:not(h3) {
            display: none;
        }

        label {
            display: block;
            color: var(--muted);
            font-size: 12px;
            margin: 6px 0 4px;
        }

        input,
        select,
        button,
        textarea {
            width: 100%;
            background: #0f1326;
            color: #e8f1ff;
            border: 1px solid #2b315c;
            border-radius: 6px;
            padding: 8px;
            font-size: 13px;
            transition: border-color .15s ease, box-shadow .15s ease, background .15s ease;
        }

        button {
            background: #13233a;
            border-color: #274666;
            cursor: pointer;
        }

        button.primary {
            background: #12324e;
            border-color: #1b6ea7;
        }

        button:hover {
            filter: brightness(1.05);
        }

        button:active {
            filter: brightness(0.98);
        }

        input:focus,
        select:focus,
        textarea:focus,
        button:focus {
            outline: none;
            border-color: #2f66a7;
            box-shadow: 0 0 0 2px rgba(53, 185, 255, 0.2);
        }

        button.inline {
            width: auto;
            padding: 6px 10px;
        }

        .row {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .row>* {
            flex: 1;
        }

        .row.no-flex>* {
            flex: 0 0 auto;
        }

        input[type="checkbox"] {
            width: auto;
            height: auto;
        }

        /* Slider styling */
        input[type="range"] {
            appearance: none;
            -webkit-appearance: none;
            height: 28px;
            background: transparent;
        }

        input[type="range"]::-webkit-slider-runnable-track {
            height: 6px;
            background: #1a2242;
            border-radius: 999px;
            border: 1px solid #2b315c;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #35b9ff;
            margin-top: -5px;
            box-shadow: 0 0 0 2px #0f1326;
        }

        input[type="range"]::-moz-range-track {
            height: 6px;
            background: #1a2242;
            border-radius: 999px;
            border: 1px solid #2b315c;
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #35b9ff;
            border: none;
        }

        .chk {
            display: flex;
            align-items: center;
            gap: 6px;
            width: auto;
            margin-right: 8px;
            user-select: none;
        }

        .kv {
            font-size: 12px;
            color: var(--muted);
            display: flex;
            justify-content: space-between;
            gap: 8px;
            padding: 2px 0;
        }

        .log {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 12px;
            height: 140px;
            background: #0b0f1f;
            padding: 8px;
            border-radius: 6px;
            overflow: auto;
        }

        .alarm {
            color: var(--danger);
        }

        .tooltip {
            position: absolute;
            pointer-events: none;
            background: #0b0f1f;
            border: 1px solid #2b315c;
            padding: 6px 8px;
            border-radius: 6px;
            font-size: 12px;
            color: #e8f1ff;
            transform: translate(-50%, -120%);
            display: none;
            white-space: pre;
            /* allow multi-line */
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.35);
        }

        .tooltip.show {
            display: block;
        }

        canvas {
            display: block;
        }

        /* Status bar */
        .statusbar {
            position: absolute;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(18, 22, 40, 0.9);
            border-top: 1px solid #212649;
            padding: 6px 10px;
            font-size: 12px;
            color: #cfe2ff;
            display: flex;
            gap: 12px;
            align-items: center;
            pointer-events: none;
        }

        .statusbar span+span {
            position: relative;
            padding-left: 10px;
        }

        .statusbar span+span::before {
            content: '\2022';
            position: absolute;
            left: 0;
            top: 0;
            color: #3c4570;
        }

        .statusbar .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 6px;
        }

        .statusbar .ok {
            background: #57d38c;
        }

        .statusbar .bad {
            background: #ff4d4f;
        }

        .statusbar .muted {
            opacity: .7;
        }

        @media (max-width: 900px) {
            #app {
                grid-template-columns: 1fr;
                grid-template-rows: 52px auto 1fr;
                grid-template-areas: 'top' 'left' 'main';
            }

            .splitter {
                display: none;
            }

            .conn {
                flex-wrap: nowrap;
                gap: 6px;
            }

            .conn button {
                padding: 6px 10px;
                font-size: 13px;
                white-space: nowrap;
            }

            .sidebar-toggle {
                display: block;
                margin-right: 8px;
            }

            aside {
                max-height: 45vh;
                transition: transform 0.3s ease, opacity 0.3s ease;
                position: relative;
                z-index: 10;
            }

            aside.collapsed {
                transform: translateY(-100%);
                opacity: 0;
                pointer-events: none;
                max-height: 0;
                padding: 0 12px;
                overflow: hidden;
            }
        }
    </style>
</head>

<body>
    <div id="app">
        <header>
            <h1>3D Industrial Plant Simulator</h1>
            <div class="conn">
                <button id="btnSidebarToggle" class="sidebar-toggle">☰ Controls</button>
                <button id="btnRun" class="inline primary">Start</button>
                <button id="btnPause" class="inline">Pause</button>
                <button id="btnEStop" class="inline"
                    style="border-color:#5a2a2b;background:#2a1314;color:#ffb3b3">E-STOP</button>
            </div>
        </header>
        <aside>
            <div class="row no-flex" style="justify-content: space-between; margin: 2px 2px 8px 2px;">
                <button id="btnExpandAll" class="inline" style="padding:4px 8px">Expand All</button>
                <button id="btnCollapseAll" class="inline" style="padding:4px 8px">Collapse All</button>
            </div>
            <div class="section">
                <h3>MQTT</h3>
                <div class="section-body">
                    <label>Broker URL (WS)</label>
                    <input id="mqttUrl" placeholder="ws://localhost:9001" />
                    <div class="row">
                        <div>
                            <label>User</label>
                            <input id="mqttUser" placeholder="optional" />
                        </div>
                        <div>
                            <label>Password</label>
                            <input id="mqttPass" placeholder="optional" type="password" />
                        </div>
                    </div>
                    <div class="row">
                        <div>
                            <label>Base Topic</label>
                            <input id="baseTopic" placeholder="plant-xxxxx" />
                        </div>
                        <div>
                            <label>QoS</label>
                            <select id="qos">
                                <option>0</option>
                                <option selected>1</option>
                                <option>2</option>
                            </select>
                        </div>
                    </div>
                    <div class="row">
                        <div>
                            <!-- Publish interval removed; simulator uses a fixed internal interval -->
                        </div>
                        <div></div>
                    </div>
                    <div class="row" style="margin-top:8px">
                        <button id="btnConnect" class="inline">Connect</button>
                    </div>
                </div>
            </div>

            <div class="section">
                <h3>Conveyor</h3>
                <div class="section-body">
                    <div class="kv"><span>Speed (m/s)</span><strong id="convSpeedVal">0.00</strong></div>
                    <input id="convSpeed" type="range" min="0" max="2" step="0.01" value="0" />
                    <div class="row">
                        <button id="convStart" class="inline">Start</button>
                        <button id="convStop" class="inline">Stop</button>
                    </div>
                </div>
            </div>

            <div class="section">
                <h3>Quality Control Station</h3>
                <div class="section-body">
                    <div class="kv"><span>Pass Rate Target</span><strong id="qcRateVal">0.90</strong></div>
                    <input id="qcRate" type="range" min="0" max="1" step="0.01" value="0.90" />
                    <div class="kv"><span>Last Result</span><strong id="qcLast">—</strong></div>
                </div>
            </div>

            <div class="section">
                <h3>Production Order</h3>
                <div class="section-body">
                    <label>Order ID</label>
                    <input id="poId" placeholder="PO-001" />
                    <div class="row no-flex" style="margin-top:8px">
                        <label class="chk"><input type="checkbox" id="poBox" checked /> <span>Box</span></label>
                        <label class="chk"><input type="checkbox" id="poCyl" checked /> <span>Cylinder</span></label>
                    </div>
                    <div class="row no-flex" style="margin-top:6px">
                        <label class="chk"><input type="checkbox" id="poLarge" /> <span>Large only</span></label>
                    </div>
                    <div class="row" style="margin-top:8px">
                        <button id="poSubmit" class="inline">Submit</button>
                    </div>
                </div>
            </div>
        </aside>
        <div id="splitter" class="splitter" title="Drag to resize"></div>
        <main>
            <div id="scene"></div>
            <div id="tooltip" class="tooltip"></div>
            <div id="statusbar" class="statusbar">
                <span><span id="sbConn" class="dot bad"></span>MQTT</span>
                <span class="muted">Speed: <strong id="sbSpeed">0.00</strong> m/s</span>
                <span class="muted">WIP: <strong id="sbWip">0</strong></span>
                <span class="muted">Produced: <strong id="sbProduced">0</strong></span>
                <span class="muted">Passed: <strong id="sbPassed">0</strong></span>
                <span class="muted">Rejected: <strong id="sbRejected">0</strong></span>
            </div>
        </main>
    </div>

    <!-- CDNs: Three.js r128, OrbitControls, mqtt.js -->
    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
    <!-- Real QR code generator (synchronous) -->
    <script src="https://unpkg.com/qrcode-generator@1.4.4/qrcode.js"></script>

    <script>
        // Basic utilities
        const clamp = (v, min, max) => Math.min(max, Math.max(min, v));
        const lerp = (a, b, t) => a + (b - a) * t;
        const nowISO = () => new Date().toISOString();
        // ID + pseudo-QR utilities
        function genId() {
            if (window.crypto && crypto.getRandomValues) {
                const a = new Uint32Array(3); crypto.getRandomValues(a);
                return [...a].map(x => x.toString(36)).join('-');
            }
            return Math.random().toString(36).slice(2) + '-' + Date.now().toString(36);
        }
        function makeQRTexture(data, size = 128) {
            const value = (typeof data === 'string') ? data : JSON.stringify(data);
            // Try real QR generator first
            if (typeof window !== 'undefined' && typeof window.qrcode === 'function') {
                const qr = window.qrcode(0, 'M'); // auto version, medium EC
                qr.addData(value);
                qr.make();
                const count = qr.getModuleCount();
                const canvas = document.createElement('canvas');
                canvas.width = size; canvas.height = size;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, size, size);
                const marginCells = 4; // quiet zone
                const scale = Math.floor(size / (count + marginCells * 2)) || 1;
                const total = scale * (count + marginCells * 2);
                const offset = Math.floor((size - scale * count) / 2);
                ctx.fillStyle = '#000';
                for (let r = 0; r < count; r++) {
                    for (let c = 0; c < count; c++) {
                        if (qr.isDark(r, c)) {
                            ctx.fillRect(offset + c * scale, offset + r * scale, scale, scale);
                        }
                    }
                }
                const tex = new THREE.CanvasTexture(canvas);
                tex.anisotropy = 4; tex.needsUpdate = true;
                return tex;
            }
            // Fallback: simple text marker
            const c = document.createElement('canvas'); c.width = size; c.height = size;
            const ctx = c.getContext('2d');
            ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, size, size);
            ctx.fillStyle = '#000'; ctx.font = 'bold 16px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText('QR', size / 2, size / 2);
            const tex = new THREE.CanvasTexture(c); tex.anisotropy = 4; tex.needsUpdate = true; return tex;
        }

        // Item ID builder: <orderId>_<random>
        function randStr(n = 8) {
            try {
                const a = new Uint32Array(2); crypto.getRandomValues(a);
                return [...a].map(x => x.toString(36)).join('').slice(0, n);
            } catch {
                return Math.random().toString(36).slice(2, 2 + n);
            }
        }
        function genItemId(orderId) {
            const prefix = (orderId || 'PO').toString().trim();
            return `${prefix}_${randStr(8)}`;
        }

        // Configuration and in-memory state
        // Randomize base topic per session to avoid collisions when sharing a broker
        const randomBase = (() => {
            try {
                const a = new Uint32Array(2); crypto.getRandomValues(a);
                return 'plant-' + [...a].map(x => x.toString(36)).join('').slice(0, 6);
            } catch {
                return 'plant-' + Math.random().toString(36).slice(2, 8);
            }
        })();
        const cfg = {
            baseTopic: randomBase,
            qos: 1,
            mqtt: { url: 'ws://localhost:9001', user: '', pass: '' }
        };
        const state = {
            running: false,
            emergency: false,
            // equipment states
            conveyor01: { speedSet: 0, speedActual: 0, enabled: false },
            qc01: { passRate: 0.9, last: null, lastId: null },
            // production order (affects spawn only)
            production: { orderId: 'PO-001', filters: { box: true, cylinder: true }, largeOnly: false },
            // discrete-event line state (belts and items)
            line: {
                belts: {}, // id -> { id, start:THREE.Vector3, dir:THREE.Vector3, length:Number, speed:Number, mesh, nextPass, nextFail }
                items: [], // { id, beltId, s (0..1), size, color, good, evaluated, mesh }
                counts: { produced: 0, passed: 0, rejected: 0 },
                photoeyes: [], // { id, beltId, sPos, blocked(0/1), beam:THREE.Mesh }
                vision: [] // { id, beltId, sPos, detectedId, group }
            },
            // MQTT
            client: null,
            connected: false,
            connecting: false,
            dataCount: 0,
            lastDataTs: 0,
            alarms: []
        };

        // UI wiring
        const $ = sel => document.querySelector(sel);
        function log(msg) { console.log(msg); }

        // Update UI from state
        function syncUI() {
            // Only update MQTT fields if they're not currently being edited
            const mqttUrl = $('#mqttUrl'); if (mqttUrl && mqttUrl !== document.activeElement) mqttUrl.value = cfg.mqtt.url;
            const mqttUser = $('#mqttUser'); if (mqttUser && mqttUser !== document.activeElement) mqttUser.value = cfg.mqtt.user;
            const mqttPass = $('#mqttPass'); if (mqttPass && mqttPass !== document.activeElement) mqttPass.value = cfg.mqtt.pass;
            const baseTopic = $('#baseTopic'); if (baseTopic && baseTopic !== document.activeElement) baseTopic.value = cfg.baseTopic;
            $('#qos').value = String(cfg.qos);
            // publish interval control removed

            $('#convSpeed').value = state.conveyor01.speedSet;
            $('#convSpeedVal').textContent = state.conveyor01.speedActual.toFixed(2);
            const sbSpeed = document.getElementById('sbSpeed');
            if (sbSpeed) sbSpeed.textContent = state.conveyor01.speedActual.toFixed(2);
            // removed pump/tank UI
            $('#qcRate').value = state.qc01.passRate;
            $('#qcRateVal').textContent = state.qc01.passRate.toFixed(2);
            $('#qcLast').textContent = state.qc01.last === null ? '—' : (state.qc01.last ? 'PASS' : 'FAIL');
            // Production order UI is synced separately to avoid overriding user checkbox clicks
            const po = state.production;
            const elId = document.getElementById('poId'); if (elId && elId !== document.activeElement) elId.value = po.orderId;
            // line stats
            const line = state.line;
            if (line) {
                const wip = line.items.length;
                const c = line.counts || { produced: 0, passed: 0, rejected: 0 };
                const setText = (id, v) => { const el = document.getElementById(id); if (el) el.textContent = String(v); };
                // status bar values
                setText('sbWip', wip);
                setText('sbProduced', c.produced || 0);
                setText('sbPassed', c.passed || 0);
                setText('sbRejected', c.rejected || 0);
            }

            const conn = $('#connState');
            if (conn) {
                conn.textContent = state.connected ? 'Connected' : 'Disconnected';
                conn.classList.toggle('ok', state.connected);
                conn.classList.toggle('bad', !state.connected);
            }
            // status bar dot
            const sbConn = document.getElementById('sbConn');
            if (sbConn) {
                sbConn.classList.toggle('ok', state.connected);
                sbConn.classList.toggle('bad', !state.connected);
            }

            const dataPill = $('#dataState');
            if (dataPill) {
                if (state.dataCount > 0) {
                    const age = Math.max(0, Math.floor((Date.now() - state.lastDataTs) / 1000));
                    dataPill.textContent = `Data ${state.dataCount} (last ${age}s)`;
                    dataPill.classList.add('ok');
                    dataPill.classList.remove('bad');
                } else {
                    dataPill.textContent = 'No data';
                    dataPill.classList.remove('ok');
                    dataPill.classList.add('bad');
                }
            }

            const btnConn = document.getElementById('btnConnect');
            if (btnConn) {
                if (state.connecting) {
                    btnConn.textContent = 'Connecting...';
                    btnConn.disabled = true;
                } else {
                    btnConn.textContent = state.connected ? 'Disconnect' : 'Connect';
                    btnConn.disabled = false;
                }
            }

            // Beacon
            // beacon removed
        }

        // Sync production order controls (call on init and after submit)
        function syncProductionUI(force = true) {
            const po = state.production;
            const elId = document.getElementById('poId');
            if (elId && (force || elId !== document.activeElement)) elId.value = po.orderId || '';
            const elBx = document.getElementById('poBox'); if (elBx) elBx.checked = !!po.filters.box;
            const elCy = document.getElementById('poCyl'); if (elCy) elCy.checked = !!po.filters.cylinder;
            const elLg = document.getElementById('poLarge'); if (elLg) elLg.checked = !!po.largeOnly;
        }

        // MQTT topic helpers
        const topic = (area, equip, type, name) => `${cfg.baseTopic}/${area}/${equip}/${type}/${name}`;

        // Simple toast for error messages
        function showToast(msg, kind = 'error', ms = 3000) {
            let el = document.getElementById('toast');
            if (!el) {
                el = document.createElement('div');
                el.id = 'toast';
                el.style.position = 'fixed';
                el.style.right = '16px';
                el.style.bottom = '16px';
                el.style.zIndex = '9999';
                el.style.maxWidth = '360px';
                el.style.padding = '10px 12px';
                el.style.borderRadius = '8px';
                el.style.fontSize = '13px';
                el.style.background = 'rgba(255,77,79,0.95)';
                el.style.color = '#fff';
                el.style.boxShadow = '0 6px 16px rgba(0,0,0,.3)';
                document.body.appendChild(el);
            }
            el.textContent = msg;
            // Light green for success, red for error
            if (kind === 'success') {
                el.style.background = 'rgba(87,211,140,0.95)'; // light green
            } else {
                el.style.background = 'rgba(255,77,79,0.95)'; // red for error
            }
            el.style.display = 'block';
            clearTimeout(el._t);
            el._t = setTimeout(() => { el.style.display = 'none'; }, ms);
        }

        // MQTT connect/disconnect
        function connectMQTT() {
            if (state.client) { try { state.client.end(true); } catch (e) { } }
            state.connecting = true;
            state.connected = false;
            syncUI();

            // Set a 5-second timeout for the connecting state
            const connectingTimeout = setTimeout(() => {
                if (state.connecting) {
                    state.connecting = false;
                    state.connected = false;
                    syncUI();
                    log('MQTT connection timeout after 5 seconds');
                    showToast('Connection timeout - failed to connect within 5 seconds', 'error');
                    // Clean up the client
                    if (state.client) {
                        try { state.client.end(true); } catch (e) { }
                        state.client = null;
                    }
                }
            }, 5000);

            const opts = {
                username: cfg.mqtt.user || undefined,
                password: cfg.mqtt.pass || undefined,
                reconnectPeriod: 0,
                keepalive: 60,
                connectTimeout: 10_000,
                protocolVersion: 4,
                clean: true,
            };
            log(`Connecting MQTT ${cfg.mqtt.url} ...`);

            try {
                state.client = mqtt.connect(cfg.mqtt.url, opts);
            } catch (e) {
                // Handle synchronous errors (e.g., invalid URL format)
                clearTimeout(connectingTimeout);
                state.connecting = false;
                state.connected = false;
                syncUI();
                log('MQTT connection error (sync): ' + e.message);
                showToast('MQTT connection failed: ' + e.message, 'error');
                return;
            }

            const c = state.client;
            c.on('connect', () => {
                clearTimeout(connectingTimeout); // Clear the timeout on successful connect
                state.connecting = false;
                state.connected = true;
                syncUI();
                log('MQTT connected');
                showToast('MQTT connected successfully', 'success', 2000);
                // subscribe to actuator setpoints & commands
                const subs = [
                    `${cfg.baseTopic}/+/+/actuators/+`,
                    `${cfg.baseTopic}/system/+/commands/+`,
                    `${cfg.baseTopic}/+/+/sensors/+`,
                ];
                subs.forEach(s => c.subscribe(s, { qos: cfg.qos }));
            });
            c.on('close', () => {
                clearTimeout(connectingTimeout); // Clear the timeout on close
                state.connecting = false;
                state.connected = false;
                syncUI();
                log('MQTT disconnected');
            });
            c.on('error', (e) => {
                clearTimeout(connectingTimeout); // Clear the timeout on error
                state.connecting = false;
                state.connected = false;
                syncUI();
                log('MQTT error: ' + e.message);
                showToast('MQTT connection failed: ' + e.message, 'error');
            });
            c.on('offline', () => {
                clearTimeout(connectingTimeout); // Clear the timeout on offline
                state.connecting = false;
                state.connected = false;
                syncUI();
                log('MQTT went offline');
            });
            c.on('message', (t, payload) => handleIncoming(t, payload));
        }

        function publish(t, obj) {
            if (!state.connected) return;
            try {
                state.client.publish(t, JSON.stringify(obj), { qos: cfg.qos, retain: false });
            } catch (e) { log('Publish error: ' + e.message); }
        }

        // Publish without JSON encoding (simple scalar/string). Useful for per-field subtopics.
        function publishRaw(t, value) {
            if (!state.connected) return;
            try {
                const payload = (value === null || value === undefined) ? '' : String(value);
                state.client.publish(t, payload, { qos: cfg.qos, retain: false });
            } catch (e) { log('PublishRaw error: ' + e.message); }
        }

        // Publish a JSON object at base topic and also each field on subtopics: base/<key>
        function publishBundle(baseTopic, payloadObj) {
            try {
                publish(baseTopic, payloadObj);
                if (payloadObj && typeof payloadObj === 'object') {
                    Object.entries(payloadObj).forEach(([k, v]) => publishRaw(`${baseTopic}/${k}`, v));
                }
            } catch (e) { log('PublishBundle error: ' + e.message); }
        }

        function message(value, unit, alarm = 'normal', quality = 'good') {
            return { timestamp: nowISO(), value, unit, quality, alarm_state: alarm };
        }

        function handleIncoming(t, payload) {
            try {
                const txt = new TextDecoder().decode(payload);
                const data = JSON.parse(txt);
                // Example topics (kept minimal):
                // plant/production/conveyor01/actuators/speed_setpoint
                // plant/safety/emergency_stop/sensors/status
                const parts = t.split('/');
                // [plant, area, equip, type, name]
                const area = parts[1];
                const equip = parts[2];
                const type = parts[3];
                const name = parts[4];
                if (type === 'actuators') {
                    if (equip === 'conveyor01' && name === 'speed_setpoint') {
                        state.conveyor01.speedSet = clamp(Number(data.value) || 0, 0, 2);
                        log(`Setpoint conveyor01 speed = ${state.conveyor01.speedSet.toFixed(2)} m/s`);
                    }
                }
                if (type === 'sensors') {
                    state.dataCount++;
                    state.lastDataTs = Date.now();
                    syncUI();
                }
                if (area === 'safety' && equip === 'emergency_stop' && (type === 'commands' || type === 'sensors') && name === 'status') {
                    const on = Boolean(data.value);
                    state.emergency = on;
                    log('Emergency ' + (on ? 'ENGAGED' : 'CLEARED'));
                }
            } catch (e) { log('Handle message error: ' + e.message); }
        }

        // Simulation loop
        let lastMs = performance.now();
        let pubAcc = 0;
        const PUB_INTERVAL_MS = 1000; // fixed publish interval
        const sensors = {
            // return value and unit
            conveyor_speed() {
                // add small noise & lag
                const target = state.conveyor01.enabled && !state.emergency ? state.conveyor01.speedSet : 0;
                state.conveyor01.speedActual = lerp(state.conveyor01.speedActual, target, 0.05) + (Math.random() - 0.5) * 0.01;
                state.conveyor01.speedActual = clamp(state.conveyor01.speedActual, 0, 2);
                return [state.conveyor01.speedActual, 'm/s'];
            },
            proximity() {
                // digital proximity based on items near QC region on main belt (~0.6..0.75)
                const items = state.line.items || [];
                let on = 0;
                for (let it of items) {
                    if (it.beltId === 'beltA' && it.s > 0.6 && it.s < 0.75) { on = 1; break; }
                }
                return [on, 'bool'];
            },
            quality() {
                // report last QC evaluation from item routing; null -> 0
                const last = state.qc01.last;
                return [last ? 1 : 0, 'bool'];
            }
        };

        // alarms removed for now

        function tick() {
            const t = performance.now();
            const dt = (t - lastMs) / 1000;
            lastMs = t;
            if (state.running && !state.emergency) {
                // update sensors
                const [v1, u1] = sensors.conveyor_speed();
                const [v4, u4] = sensors.proximity();
                const [q1, qu1] = sensors.quality();
                state.alarms = [];

                pubAcc += dt * 1000;
                if (pubAcc >= PUB_INTERVAL_MS) {
                    pubAcc = 0;
                    // Bundle publish: full JSON + per-field subtopics
                    const pub = (tpc, obj) => publishBundle(tpc, obj);
                    // Sensors
                    pub(topic('production', 'conveyor01', 'sensors', 'speed'), message(Number(v1.toFixed(3)), u1));
                    pub(topic('production', 'qc01', 'sensors', 'proximity'), message(v4, u4));
                    pub(topic('production', 'qc01', 'sensors', 'quality'), message(q1, 'bool'));
                    // Photoeye sensors: publish as plant/production/<beltId>/sensors/photoeye_<pos>
                    if (state.line.photoeyes && state.line.photoeyes.length) {
                        for (const pe of state.line.photoeyes) {
                            const pos = pe.id.includes('start') ? 'start' : 'end';
                            pub(topic('production', pe.beltId, 'sensors', `photoeye_${pos}`), message(pe.blocked, 'bool'));
                        }
                    }
                    // Vision sensors: publish full tag object or null
                    if (state.line.vision && state.line.vision.length) {
                        for (const vg of state.line.vision) {
                            const payload = vg.detected ? { ...vg.detected } : null;
                            const base = topic('production', vg.beltId, 'sensors', `vision_${vg.id.includes('start') ? 'start' : 'end'}`);
                            if (payload) {
                                // add a measurement timestamp for the scan event
                                payload.timestamp = nowISO();
                                pub(base, payload);
                            } else {
                                // publish a full JSON with empty strings (no nulls)
                                const empty = { timestamp: nowISO(), pieceID: '', orderID: '', type: '', start_timestamp: '' };
                                pub(base, empty);
                            }
                        }
                    }
                    pub(`${cfg.baseTopic}/safety/emergency_stop/sensors/status`, message(state.emergency ? 1 : 0, 'bool'));
                    // Heartbeat/metrics
                    publishBundle(`${cfg.baseTopic}/system/simulator/metrics/heartbeat`, { timestamp: nowISO(), up_ms: Math.floor(performance.now()) });
                }
            }

            // update production line
            updateLine(dt);
            // render 3D
            render3D(dt);
            requestAnimationFrame(tick);
        }

        // 3D scene
        let renderer, scene, camera, controls, raycaster, mouse, tooltipEl;
        const objs = {};

        function setup3D() {
            const container = document.getElementById('scene');
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(devicePixelRatio);
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setClearColor(0x0b0f1f, 1);
            container.appendChild(renderer.domElement);

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(58, container.clientWidth / container.clientHeight, 0.1, 1000);
            // Shift slightly to the right (increase X) and zoom in (reduce Z)
            camera.position.set(11, 5, 5);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.08;
            controls.maxDistance = 60;

            // Lights
            const hemi = new THREE.HemisphereLight(0xcfe8ff, 0x223355, 0.6);
            scene.add(hemi);
            const dir = new THREE.DirectionalLight(0xffffff, 0.8);
            dir.position.set(5, 10, 7);
            dir.castShadow = false;
            scene.add(dir);


            // Floor
            const floorGeo = new THREE.PlaneGeometry(100, 100);
            // subtle checker for factory tiles
            const floorCanvas = document.createElement('canvas'); floorCanvas.width = 256; floorCanvas.height = 256;
            const fctx = floorCanvas.getContext('2d');
            for (let y = 0; y < 8; y++) {
                for (let x = 0; x < 8; x++) {
                    fctx.fillStyle = ((x + y) % 2 === 0) ? '#1a213c' : '#1c2440';
                    fctx.fillRect(x * 32, y * 32, 32, 32);
                }
            }
            const floorTex = new THREE.CanvasTexture(floorCanvas); floorTex.wrapS = floorTex.wrapT = THREE.RepeatWrapping; floorTex.repeat.set(8, 8);
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x1b213d, roughness: 0.95, metalness: 0.05, map: floorTex });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            scene.add(floor);


            // Helper: procedural belt texture
            function createBeltTexture() {
                const c = document.createElement('canvas');
                c.width = 256; c.height = 64;
                const ctx = c.getContext('2d');
                // background
                ctx.fillStyle = '#1a223d';
                ctx.fillRect(0, 0, c.width, c.height);
                // stripes
                ctx.fillStyle = 'rgba(255,255,255,0.08)';
                for (let x = 0; x < c.width; x += 16) {
                    ctx.fillRect(x, 0, 8, c.height);
                }
                const tex = new THREE.CanvasTexture(c);
                tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
                return tex;
            }

            // Conveyors network (3 belts: main A detailed, pass B and reject C simple)
            function makeBelt(id, start, dir, length, color = 0x1e9dd8, detailed = false) {
                const beltW = 1, h = 0.7;
                const yaw = Math.atan2(dir.z, dir.x);
                if (!detailed) {
                    // simple belt (B, C)
                    const frame = new THREE.Mesh(
                        new THREE.BoxGeometry(length, 0.2, beltW + 0.4),
                        new THREE.MeshStandardMaterial({ color: 0x3a4a6e, metalness: 0.6, roughness: 0.4 })
                    );
                    const belt = new THREE.Mesh(
                        new THREE.BoxGeometry(length, 0.1, beltW),
                        new THREE.MeshStandardMaterial({ color, metalness: 0.2, roughness: 0.8 })
                    );
                    frame.position.copy(start).add(dir.clone().multiplyScalar(length / 2)).setY(h - 0.1);
                    belt.position.copy(start).add(dir.clone().multiplyScalar(length / 2)).setY(h);
                    frame.rotation.y = yaw; belt.rotation.y = yaw;
                    scene.add(frame); scene.add(belt);
                    state.line.belts[id] = { id, start: start.clone(), dir: dir.clone().normalize(), length, speed: 1.0, mesh: belt, nextPass: null, nextFail: null };
                    return belt;
                }
                // detailed main conveyor (A)
                const group = new THREE.Group();
                group.position.copy(start).add(dir.clone().multiplyScalar(length / 2));
                group.rotation.y = yaw;
                // rails
                const railMat = new THREE.MeshStandardMaterial({ color: 0x2e385b, metalness: 0.6, roughness: 0.4 });
                const railGeo = new THREE.BoxGeometry(length, 0.14, 0.12);
                const railL = new THREE.Mesh(railGeo, railMat);
                const railR = new THREE.Mesh(railGeo, railMat);
                railL.position.set(0, -0.04, -(beltW / 2 + 0.12));
                railR.position.set(0, -0.04, (beltW / 2 + 0.12));
                group.add(railL, railR);
                // supports
                const legGeo = new THREE.BoxGeometry(0.12, 0.6, 0.12);
                const legMat = new THREE.MeshStandardMaterial({ color: 0x25304e, metalness: 0.4, roughness: 0.6 });
                for (let x = -length / 2; x <= length / 2; x += 2.0) {
                    const l1 = new THREE.Mesh(legGeo, legMat); l1.position.set(x, -0.45, -(beltW / 2 + 0.12));
                    const l2 = new THREE.Mesh(legGeo, legMat); l2.position.set(x, -0.45, (beltW / 2 + 0.12));
                    group.add(l1, l2);
                }
                // rollers (pulleys) — omit termination rollers on all belts for cleaner ends
                const rollMat = new THREE.MeshStandardMaterial({ color: 0x556a8a, metalness: 0.5, roughness: 0.5 });
                const pulleyGeo = new THREE.CylinderGeometry(0.22, 0.22, beltW + 0.16, 24);
                pulleyGeo.rotateX(Math.PI / 2);
                // intentionally not added: no end rollers on any belt
                // idlers along length
                const idlerGeo = new THREE.CylinderGeometry(0.08, 0.08, beltW, 16); idlerGeo.rotateX(Math.PI / 2);
                for (let x = -length / 2 + 0.8; x < length / 2 - 0.8; x += 1.2) {
                    const idr = new THREE.Mesh(idlerGeo, rollMat); idr.position.set(x, -0.02, 0); group.add(idr);
                }
                // belt surface with moving texture
                const beltTex = createBeltTexture(); beltTex.repeat.set(length * 0.25, 1);
                const beltMat = new THREE.MeshStandardMaterial({ color: new THREE.Color(color), map: beltTex, metalness: 0.1, roughness: 0.9 });
                const beltSurf = new THREE.Mesh(new THREE.BoxGeometry(length, 0.06, beltW), beltMat);
                beltSurf.position.set(0, 0.02, 0);
                group.add(beltSurf);
                group.position.y = h;
                scene.add(group);
                state.line.belts[id] = { id, start: start.clone(), dir: dir.clone().normalize(), length, speed: 1.0, mesh: beltSurf, nextPass: null, nextFail: null, beltMat };
                return beltSurf;
            }
            objs.conveyorBelt = makeBelt('beltA', new THREE.Vector3(-3, 0, 0), new THREE.Vector3(1, 0, 0), 8, 0x1e9dd8, true);
            makeBelt('beltB', new THREE.Vector3(5, 0, 0), new THREE.Vector3(0, 0, 1), 5, 0x18c176, true);
            makeBelt('beltC', new THREE.Vector3(5, 0, 0), new THREE.Vector3(0, 0, -1), 4, 0xd75d5d, true);
            state.line.belts['beltA'].nextPass = 'beltB';
            state.line.belts['beltA'].nextFail = 'beltC';

            // Photoelectric sensors (start and end per belt)
            function placePhotoeye(id, beltId, sPos) {
                const belt = state.line.belts[beltId]; if (!belt) return null;
                const beltW = 1; // keep in sync with makeBelt
                const railOffset = 0.12; // from rails in detailed belt
                const edge = beltW / 2 + railOffset; // center over rail cap

                const postMat = new THREE.MeshStandardMaterial({ color: 0x8aa0b6, metalness: 0.2, roughness: 0.6 });
                const postRadius = 0.04;
                const postH = 0.1; // half height posts
                const postGeo = new THREE.CylinderGeometry(postRadius, postRadius, postH, 12);
                const tx = new THREE.Mesh(postGeo, postMat);
                const rx = new THREE.Mesh(postGeo, postMat);

                // Beam spans exactly between outer surfaces of the posts
                const beamRadius = 0.01;
                const centerGap = (edge * 2);
                const beamLen = Math.max(0.05, centerGap - postRadius * 2);
                const beamGeo = new THREE.CylinderGeometry(beamRadius, beamRadius, beamLen, 8);
                beamGeo.rotateZ(Math.PI / 2); // orient along local X
                const beam = new THREE.Mesh(beamGeo, new THREE.MeshBasicMaterial({ color: 0xff4d4f }));

                const p = belt.start.clone().add(belt.dir.clone().multiplyScalar(belt.length * sPos));
                const yaw = Math.atan2(belt.dir.z, belt.dir.x);
                const perp = new THREE.Vector3(-belt.dir.z, 0, belt.dir.x).normalize();
                // Rail top world height ~ h (0.7) + (-0.04 + 0.14/2) = 0.73
                const railTop = 0.73;
                const postCenterY = railTop + postH / 2; // bottom sits on rail
                const beamH = railTop + postH; // beam at top of posts
                // Place transmitter at +perp edge and receiver at -perp edge
                const txPos = p.clone().add(perp.clone().multiplyScalar(edge));
                const rxPos = p.clone().add(perp.clone().multiplyScalar(-edge));
                tx.position.set(txPos.x, postCenterY, txPos.z);
                rx.position.set(rxPos.x, postCenterY, rxPos.z);
                // Posts rotate to face across the belt (optional aesthetic)
                tx.rotation.y = yaw + Math.PI / 2;
                rx.rotation.y = yaw + Math.PI / 2;

                // Beam centered at belt center, rotated to run across (perp to belt)
                beam.position.set(p.x, beamH, p.z);
                beam.rotation.y = yaw + Math.PI / 2;

                scene.add(tx); scene.add(rx); scene.add(beam);
                // Attach pick metadata to existing components (no clones)
                tx.userData.sensor = { type: 'photoeye', id, beltId, sPos };
                rx.userData.sensor = { type: 'photoeye', id, beltId, sPos };
                beam.userData.sensor = { type: 'photoeye', id, beltId, sPos };
                const pe = { id, beltId, sPos, blocked: 0, beam, tx, rx };
                state.line.photoeyes.push(pe);
                return pe;
            }
            // Start (~0.05) and End (~0.95) for each belt
            placePhotoeye('peA_start', 'beltA', 0.20);
            placePhotoeye('peA_end', 'beltA', 0.80);
            placePhotoeye('peB_start', 'beltB', 0.20);
            placePhotoeye('peB_end', 'beltB', 0.80);
            placePhotoeye('peC_start', 'beltC', 0.20);
            placePhotoeye('peC_end', 'beltC', 0.80);

            // removed tank/pump visuals

            // QC station at conveyor intersection with strip curtains
            function makeCurtainTexture() {
                const c = document.createElement('canvas'); c.width = 256; c.height = 256;
                const ctx = c.getContext('2d');
                // opaque rubber-like look: dark base with lighter strip highlights
                ctx.fillStyle = '#202a3f';
                ctx.fillRect(0, 0, c.width, c.height);
                for (let x = 0; x < c.width; x += 16) {
                    ctx.fillStyle = '#2b3856';
                    ctx.fillRect(x, 0, 10, c.height);
                    ctx.fillStyle = '#394867';
                    ctx.fillRect(x, 0, 2, c.height);
                    ctx.fillRect(x + 8, 0, 2, c.height);
                }
                const tex = new THREE.CanvasTexture(c);
                tex.wrapS = tex.wrapT = THREE.RepeatWrapping; tex.anisotropy = 4;
                return tex;
            }
            function makeCurtain(width, height, orientation) {
                const geo = new THREE.PlaneGeometry(width, height);
                const mat = new THREE.MeshStandardMaterial({ map: makeCurtainTexture(), metalness: 0.0, roughness: 1.0, side: THREE.DoubleSide });
                const m = new THREE.Mesh(geo, mat);
                if (orientation === 'acrossA') m.rotation.y = Math.PI / 2; // face +X/-X
                return m;
            }
            function makeQCStationIntersection() {
                const center = new THREE.Vector3(5, 0, 0); // belts meet
                const group = new THREE.Group();
                // Canopy
                const canopySizeX = 1.6, canopySizeZ = 2.2, canopyH = 1.6;
                const canopy = new THREE.Mesh(
                    new THREE.BoxGeometry(canopySizeX, 0.08, canopySizeZ),
                    new THREE.MeshStandardMaterial({ color: 0x3b4b6f, metalness: 0.4, roughness: 0.5 })
                );
                canopy.position.set(0, canopyH, 0);
                group.add(canopy);
                // (Top info panel removed — stack light only)
                // Stack light on top
                const slBase = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.12, 16), new THREE.MeshStandardMaterial({ color: 0x5c6a82, metalness: 0.4, roughness: 0.5 }));
                slBase.position.set(canopySizeX / 2 - 0.18, canopyH + 0.1, canopySizeZ / 2 - 0.18);
                const segGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.09, 20);
                const segR = new THREE.Mesh(segGeo, new THREE.MeshBasicMaterial({ color: 0xff4d4f }));
                const segY = new THREE.Mesh(segGeo, new THREE.MeshBasicMaterial({ color: 0xf5d76e }));
                const segG = new THREE.Mesh(segGeo, new THREE.MeshBasicMaterial({ color: 0x57d38c }));
                segR.position.set(slBase.position.x, slBase.position.y + 0.11, slBase.position.z);
                segY.position.set(slBase.position.x, slBase.position.y + 0.22, slBase.position.z);
                segG.position.set(slBase.position.x, slBase.position.y + 0.33, slBase.position.z);
                group.add(slBase, segR, segY, segG);
                // Posts
                const postMat = new THREE.MeshStandardMaterial({ color: 0x6b7a95, metalness: 0.2, roughness: 0.8 });
                const post = new THREE.CylinderGeometry(0.05, 0.05, canopyH, 12);
                const px = canopySizeX / 2 - 0.08, pz = canopySizeZ / 2 - 0.08;
                const p1 = new THREE.Mesh(post, postMat); p1.position.set(-px, canopyH / 2, -pz);
                const p2 = new THREE.Mesh(post, postMat); p2.position.set(px, canopyH / 2, -pz);
                const p3 = new THREE.Mesh(post, postMat); p3.position.set(-px, canopyH / 2, pz);
                const p4 = new THREE.Mesh(post, postMat); p4.position.set(px, canopyH / 2, pz);
                group.add(p1, p2, p3, p4);
                // Curtains
                const curtainH = 0.72; // from ~0.78 to ~1.5
                const baseY = 1.46; // top of curtain
                const front = makeCurtain(1.2, curtainH, 'acrossA');
                front.position.set(-0.36, baseY - curtainH / 2, 0); // slightly before center on A
                const rear = makeCurtain(1.2, curtainH, 'acrossA');
                rear.position.set(0.36, baseY - curtainH / 2, 0); // opposite side on A
                const sideB = makeCurtain(1.2, curtainH, 'front');
                sideB.position.set(0, baseY - curtainH / 2, 0.62); // towards +Z
                const sideC = makeCurtain(1.2, curtainH, 'front');
                sideC.position.set(0, baseY - curtainH / 2, -0.62); // towards -Z
                group.add(front, rear, sideB, sideC);
                group.position.copy(center);
                scene.add(group);
                objs.qcStation = { group, segR, segY, segG };
            }
            makeQCStationIntersection();

            // Diverter gate at split (routes pass/right to green or fail/left to red)
            const gatePivot = new THREE.Group();
            // raise pivot so the taller gate still clears the belt top
            gatePivot.position.set(5.0, 0.935, 0);
            const gate = new THREE.Mesh(
                // much thinner (Z) but taller (Y)
                new THREE.BoxGeometry(0.7, 0.25, 0.06),
                new THREE.MeshStandardMaterial({ color: 0xd1a21a })
            );
            gate.position.set(0, 0, 0);
            gatePivot.add(gate);
            scene.add(gatePivot);
            objs.diverter = { pivot: gatePivot, mesh: gate, angle: 0, targetAngle: 0 };

            // Hollow catch boxes at ends of branch belts
            function makeCatchBox(id, beltId, innerW = 1.2, innerL = 1.2, wall = 0.08, height = 0.6, color = 0x46506a) {
                const b = state.line.belts[beltId]; if (!b) return null;
                const group = new THREE.Group();
                const baseMat = new THREE.MeshStandardMaterial({ color, metalness: 0.4, roughness: 0.7 });
                // Base
                const base = new THREE.Mesh(new THREE.BoxGeometry(innerW + 2 * wall, wall, innerL + 2 * wall), baseMat);
                base.position.set(0, wall / 2, 0); group.add(base);
                // Walls
                const wallLong = new THREE.BoxGeometry(innerW + 2 * wall, height, wall);
                const wallShort = new THREE.BoxGeometry(wall, height, innerL);
                const wF = new THREE.Mesh(wallLong, baseMat); wF.position.set(0, height / 2 + wall, innerL / 2);
                const wB = new THREE.Mesh(wallLong, baseMat); wB.position.set(0, height / 2 + wall, -innerL / 2);
                const wL = new THREE.Mesh(wallShort, baseMat); wL.position.set(-innerW / 2, height / 2 + wall, 0);
                const wR = new THREE.Mesh(wallShort, baseMat); wR.position.set(innerW / 2, height / 2 + wall, 0);
                group.add(wF, wB, wL, wR);
                // Place slightly beyond belt end on the floor
                const end = b.start.clone().add(b.dir.clone().multiplyScalar(b.length + 0.4));
                group.position.copy(end);
                group.position.y = 0;
                scene.add(group);
                objs[id] = group; return group;
            }
            makeCatchBox('passCatch', 'beltB');
            makeCatchBox('failCatch', 'beltC');

            // Vision gate sensors (A after QR station, B end, C end)
            function placeVisionGate(id, beltId, sPos) {
                const belt = state.line.belts[beltId]; if (!belt) return null;
                const group = new THREE.Group();
                const railTop = 0.73;
                const beltW = 1, railOffset = 0.12, edge = beltW / 2 + railOffset;
                const perp = new THREE.Vector3(-belt.dir.z, 0, belt.dir.x).normalize();
                const p = belt.start.clone().add(belt.dir.clone().multiplyScalar(belt.length * sPos));
                const yaw = Math.atan2(belt.dir.z, belt.dir.x);
                // Feet on rails
                const footGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.2, 12);
                const footMat = new THREE.MeshStandardMaterial({ color: 0x8aa0b6, metalness: 0.2, roughness: 0.6 });
                const footL = new THREE.Mesh(footGeo, footMat);
                const footR = new THREE.Mesh(footGeo, footMat);
                const fL = p.clone().add(perp.clone().multiplyScalar(edge));
                const fR = p.clone().add(perp.clone().multiplyScalar(-edge));
                footL.position.set(fL.x, railTop + 0.1, fL.z);
                footR.position.set(fR.x, railTop + 0.1, fR.z);
                group.add(footL, footR);
                // Uprights and top bar
                const uprH = 0.7; // height above feet
                const uprGeo = new THREE.BoxGeometry(0.08, uprH, 0.08);
                const uprMat = new THREE.MeshStandardMaterial({ color: 0x657a9a });
                const upr1 = new THREE.Mesh(uprGeo, uprMat); const upr2 = new THREE.Mesh(uprGeo, uprMat);
                upr1.position.set(fL.x, railTop + 0.1 + uprH / 2, fL.z);
                upr2.position.set(fR.x, railTop + 0.1 + uprH / 2, fR.z);
                const topGeo = new THREE.BoxGeometry(edge * 2 + 0.12, 0.08, 0.1);
                const top = new THREE.Mesh(topGeo, uprMat);
                top.position.set(p.x, railTop + 0.1 + uprH + 0.04, p.z);
                // Rotate the top bar so it spans across the belt (perpendicular to travel)
                top.rotation.y = yaw + Math.PI / 2;
                group.add(upr1, upr2, top);
                // Camera housing centered
                const camGeo = new THREE.BoxGeometry(0.18, 0.12, 0.12);
                const cam = new THREE.Mesh(camGeo, new THREE.MeshStandardMaterial({ color: 0x333b55, metalness: 0.3, roughness: 0.6 }));
                cam.position.set(p.x, top.position.y + 0.1, p.z);
                cam.rotation.y = yaw; // align cosmetically with belt travel
                group.add(cam);
                group.userData.sensor = { type: 'vision', id, beltId, sPos };
                scene.add(group);
                state.line.vision.push({ id, beltId, sPos, detectedId: null, group });
                return group;
            }
            placeVisionGate('vgA_start', 'beltA', 0.45);
            placeVisionGate('vgB_end', 'beltB', 0.80);
            placeVisionGate('vgC_end', 'beltC', 0.80);

            // HMI near belt A (opposite side, around mid-length)
            function makeHMIScreenNearVision(id, vgId) {
                const vg = (state.line.vision || []).find(v => v.id === vgId);
                if (!vg) return null;
                const b = state.line.belts[vg.beltId]; if (!b) return null;
                const yaw = Math.atan2(b.dir.z, b.dir.x);
                const perp = new THREE.Vector3(-b.dir.z, 0, b.dir.x).normalize();
                // Place near the middle of the conveyor length on the opposite side
                const mid = b.start.clone().add(b.dir.clone().multiplyScalar(b.length * 0.5));
                const side = mid.add(perp.multiplyScalar(-0.9));
                const stand = new THREE.Group();
                const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.9, 12), new THREE.MeshStandardMaterial({ color: 0x4a5878 }));
                pole.position.set(0, 0.45, 0);
                const screen = new THREE.Mesh(
                    new THREE.PlaneGeometry(0.9, 0.55),
                    new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide })
                );
                screen.position.set(0, 1.1, 0);
                stand.add(pole, screen);
                stand.position.copy(side);
                stand.rotation.y = yaw;
                scene.add(stand);
                objs[id] = { group: stand, screen };
                return objs[id];
            }
            makeHMIScreenNearVision('hmiA', 'vgA_start');

            // Labelling station on belt A at 1/3 position (applies QR label)
            function makeLabellingStationOnA() {
                const belt = state.line.belts['beltA']; if (!belt) return;
                const sPos = 1 / 3;
                const p = belt.start.clone().add(belt.dir.clone().multiplyScalar(belt.length * sPos));
                const yaw = Math.atan2(belt.dir.z, belt.dir.x);
                const group = new THREE.Group();
                // two uprights and a roll-based applicator over the belt
                const railTop = 0.73; // same estimate used for sensors
                // Taller gantry so it clears the tallest pieces comfortably
                const h = 0.7;
                const uprGeo = new THREE.CylinderGeometry(0.04, 0.04, h, 12);
                const uprMat = new THREE.MeshStandardMaterial({ color: 0x6a7896, metalness: 0.3, roughness: 0.7 });
                const beltW = 1, railOffset = 0.12, edge = beltW / 2 + railOffset;
                const perp = new THREE.Vector3(-belt.dir.z, 0, belt.dir.x).normalize();
                const pL = p.clone().add(perp.clone().multiplyScalar(edge));
                const pR = p.clone().add(perp.clone().multiplyScalar(-edge));
                const uL = new THREE.Mesh(uprGeo, uprMat); uL.position.set(pL.x, railTop + h / 2, pL.z);
                const uR = new THREE.Mesh(uprGeo, uprMat); uR.position.set(pR.x, railTop + h / 2, pR.z);
                const bar = new THREE.Mesh(new THREE.BoxGeometry(edge * 2 + 0.12, 0.06, 0.10), uprMat);
                bar.position.set(p.x, railTop + h + 0.03, p.z);
                bar.rotation.y = yaw + Math.PI / 2; // span across the belt
                // label roll (paper) + core
                const rollRadius = 0.10, rollWidth = 0.22;
                const paperMat = new THREE.MeshStandardMaterial({ color: 0xf5f1e6, metalness: 0.0, roughness: 0.95 });
                const coreMat = new THREE.MeshStandardMaterial({ color: 0xb0b6bf, metalness: 0.3, roughness: 0.5 });
                const roll = new THREE.Mesh(new THREE.CylinderGeometry(rollRadius, rollRadius, rollWidth, 48), paperMat);
                // Axis across the belt; face centerline
                roll.rotation.set(Math.PI / 2, yaw + Math.PI / 2, 0);
                // Place slightly upstream of the peel plate
                const upstream = belt.dir.clone().multiplyScalar(-0.08);
                const rollPos = p.clone().add(upstream);
                roll.position.set(rollPos.x, bar.position.y - 0.12, rollPos.z);
                const core = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, rollWidth + 0.01, 32), coreMat);
                core.rotation.copy(roll.rotation);
                core.position.copy(roll.position);
                // Single guide plate, parallel to the station cross bar
                const guide = new THREE.Mesh(new THREE.BoxGeometry(edge * 0.8, 0.012, 0.10), new THREE.MeshStandardMaterial({ color: 0x8a95a8, metalness: 0.2, roughness: 0.6 }));
                guide.position.set(p.x, roll.position.y - 0.10, p.z);
                guide.rotation.set(0, yaw + Math.PI / 2, 0);
                // Two supports connecting guide to the cross bar (left/right along belt perpendicular)
                const halfGuide = (edge * 0.8) / 2;
                const anchorOffset = halfGuide - 0.02; // small inset from edges
                const startY = guide.position.y + 0.006; // guide top surface
                const endY = bar.position.y - 0.03; // underside of bar
                const startBase = new THREE.Vector3(guide.position.x, startY, guide.position.z);
                const endBase = new THREE.Vector3(bar.position.x, endY, bar.position.z);
                const sL = startBase.clone().add(perp.clone().multiplyScalar(-anchorOffset));
                const sR = startBase.clone().add(perp.clone().multiplyScalar(anchorOffset));
                const eL = endBase.clone().add(perp.clone().multiplyScalar(-anchorOffset));
                const eR = endBase.clone().add(perp.clone().multiplyScalar(anchorOffset));
                const makeRod = (a, b) => {
                    const v = new THREE.Vector3().subVectors(b, a);
                    const len = v.length();
                    const rod = new THREE.Mesh(new THREE.CylinderGeometry(0.012, 0.012, len, 10), uprMat);
                    rod.position.copy(new THREE.Vector3().addVectors(a, b).multiplyScalar(0.5));
                    rod.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), v.clone().normalize());
                    return rod;
                };
                const supL = makeRod(sL, eL);
                const supR = makeRod(sR, eR);
                group.add(uL, uR, bar, roll, core, guide, supL, supR);
                scene.add(group);
                objs.labelStationA = { group, sPos };
            }
            makeLabellingStationOnA();

            // Items container
            objs.itemsGroup = new THREE.Group();
            scene.add(objs.itemsGroup);

            // HMI screens at ends of belts B and C
            function makeHMIScreen(id, nearBeltId, yawOffset = 0) {
                const b = state.line.belts[nearBeltId]; if (!b) return null;
                const end = b.start.clone().add(b.dir.clone().multiplyScalar(b.length + 0.3));
                // offset to the side of belt by its perpendicular
                const perp = new THREE.Vector3(-b.dir.z, 0, b.dir.x).normalize();
                const side = end.clone().add(perp.multiplyScalar(0.9));
                const stand = new THREE.Group();
                const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.9, 12), new THREE.MeshStandardMaterial({ color: 0x4a5878 }));
                pole.position.set(0, 0.45, 0);
                const screen = new THREE.Mesh(
                    new THREE.PlaneGeometry(0.9, 0.55),
                    // Use white so the canvas texture is not multiplied/dimmed
                    new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide })
                );
                screen.position.set(0, 1.1, 0);
                // face the belt: plane faces +Z of its local; align plane normal to belt direction
                const yaw = Math.atan2(b.dir.z, b.dir.x) + yawOffset;
                stand.add(pole, screen);
                stand.position.copy(side);
                stand.rotation.y = yaw;
                scene.add(stand);
                objs[id] = { group: stand, screen };
                return objs[id];
            }
            makeHMIScreen('hmiB', 'beltB');
            // Rotate HMI on C by 180 degrees
            makeHMIScreen('hmiC', 'beltC', Math.PI);

            // Raycaster for picking
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            tooltipEl = document.getElementById('tooltip');

            window.addEventListener('resize', onResize);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('click', onClick);
        }

        // Collapsible sections in sidebar
        function setupCollapsibles() {
            const sections = document.querySelectorAll('aside .section');
            sections.forEach(sec => {
                const h = sec.querySelector('h3');
                if (!h) return;
                h.addEventListener('click', () => sec.classList.toggle('collapsed'));
            });

            const btnEx = document.getElementById('btnExpandAll');
            const btnCol = document.getElementById('btnCollapseAll');
            if (btnEx) btnEx.addEventListener('click', () => sections.forEach(s => s.classList.remove('collapsed')));
            if (btnCol) btnCol.addEventListener('click', () => sections.forEach(s => s.classList.add('collapsed')));
        }

        function setupSidebarToggle() {
            const toggleBtn = document.getElementById('btnSidebarToggle');
            const sidebar = document.querySelector('aside');

            if (!toggleBtn || !sidebar) return;

            // Start with sidebar collapsed on mobile
            if (window.innerWidth <= 900) {
                sidebar.classList.add('collapsed');
                toggleBtn.textContent = '☰ Show Controls';
            }

            toggleBtn.addEventListener('click', () => {
                sidebar.classList.toggle('collapsed');
                const isCollapsed = sidebar.classList.contains('collapsed');
                toggleBtn.textContent = isCollapsed ? '☰ Show Controls' : '✕ Hide Controls';
            });

            // Handle window resize
            window.addEventListener('resize', () => {
                if (window.innerWidth > 900) {
                    sidebar.classList.remove('collapsed');
                    toggleBtn.textContent = '☰ Controls';
                }
            });
        }

        function onResize() {
            const container = document.getElementById('scene');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        // Sidebar resizer
        (function setupResizer() {
            const splitter = document.getElementById('splitter');
            if (!splitter) return;
            let dragging = false;
            splitter.addEventListener('mousedown', () => { dragging = true; document.body.style.userSelect = 'none'; });
            window.addEventListener('mouseup', () => { if (dragging) { dragging = false; document.body.style.userSelect = ''; } });
            window.addEventListener('mousemove', (e) => {
                if (!dragging) return;
                const min = 240, max = window.innerWidth * 0.6;
                const w = clamp(e.clientX, min, max);
                document.documentElement.style.setProperty('--sidebar', w + 'px');
                onResize();
            });
        })();

        let tooltipLock = null; // { type, id } or null
        function setTooltip(e, text) {
            tooltipEl.style.left = e.clientX + 'px';
            tooltipEl.style.top = e.clientY + 'px';
            tooltipEl.style.display = 'block';
            tooltipEl.textContent = text;
        }

        function onMouseMove(e) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = - ((e.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const targetList = [objs.conveyorBelt];
            // add sensor meshes (photoeye parts and vision groups)
            if (state.line.photoeyes) state.line.photoeyes.forEach(pe => { if (pe.tx) targetList.push(pe.tx); if (pe.rx) targetList.push(pe.rx); if (pe.beam) targetList.push(pe.beam); });
            if (state.line.vision) state.line.vision.forEach(v => v.group && targetList.push(v.group));
            const hits = raycaster.intersectObjects(targetList, true);
            if (hits.length && !tooltipLock) {
                const obj = hits[0].object;
                // find root with userData.sensor
                let p = obj; let sensor = null;
                while (p) { if (p.userData && p.userData.sensor) { sensor = p.userData.sensor; break; } p = p.parent; }
                if (sensor && sensor.type === 'photoeye') {
                    const pe = state.line.photoeyes.find(x => x.id === sensor.id);
                    const val = pe ? pe.blocked : 0;
                    setTooltip(e, `Photoeye ${sensor.id}\nBelt: ${sensor.beltId}\nBlocked: ${val}`);
                } else if (sensor && sensor.type === 'vision') {
                    const vg = state.line.vision.find(x => x.id === sensor.id);
                    const tag = vg && vg.detected ? vg.detected : { pieceID: '', orderID: '', type: '', start_timestamp: '' };
                    setTooltip(e, `Vision ${sensor.id}\nBelt: ${sensor.beltId}\nPiece: ${tag.pieceID || '(none)'}\nOrder: ${tag.orderID || ''}\nType: ${tag.type || ''}`);
                } else if (obj === objs.conveyorBelt) {
                    setTooltip(e, `Conveyor speed: ${state.conveyor01.speedActual.toFixed(2)} m/s`);
                } else {
                    tooltipEl.style.display = 'none';
                }
            } else if (!tooltipLock) {
                tooltipEl.style.display = 'none';
            }
        }

        function onClick(e) {
            // Toggle tooltip lock on sensor click
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = - ((e.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const targets = [];
            if (state.line.photoeyes) state.line.photoeyes.forEach(pe => { if (pe.tx) targets.push(pe.tx); if (pe.rx) targets.push(pe.rx); if (pe.beam) targets.push(pe.beam); });
            if (state.line.vision) state.line.vision.forEach(v => v.group && targets.push(v.group));
            const hits = raycaster.intersectObjects(targets, true);
            if (hits.length) {
                let p = hits[0].object; let sensor = null;
                while (p) { if (p.userData && p.userData.sensor) { sensor = p.userData.sensor; break; } p = p.parent; }
                if (sensor) { tooltipLock = (tooltipLock && tooltipLock.id === sensor.id) ? null : sensor; }
            } else {
                tooltipLock = null;
            }
        }

        function render3D(dt) {
            // Animate visuals
            if (objs.conveyorBelt) {
                const s = state.conveyor01.speedActual;
                objs.conveyorBelt.material.color.setHSL(0.55 + s * 0.05, 0.7, 0.5);
            }
            // scroll textures on all detailed belts with a gentler speed
            if (state.line && state.line.belts) {
                const belts = state.line.belts;
                for (const key of Object.keys(belts)) {
                    const b = belts[key];
                    if (b && b.beltMat && b.beltMat.map) {
                        const dir = (b.id === 'beltA') ? -1 : 1; // flip A only
                        b.beltMat.map.offset.x = (b.beltMat.map.offset.x + dir * (b.speed || 0) * dt * 0.25) % 1;
                        b.beltMat.needsUpdate = true;
                    }
                }
            }
            // removed tank/pump visuals

            // Diverter animation
            if (objs.diverter) {
                const d = objs.diverter;
                d.angle = lerp(d.angle, d.targetAngle, 0.1);
                d.pivot.rotation.y = d.angle;
            }

            // Update HMI screens with latest vision reads for B and C
            function updateHMIScreen(hmiId, visionIdPrefix) {
                const h = objs[hmiId]; if (!h || !h.screen) return;
                const vg = (state.line.vision || []).find(v => v.id.startsWith(visionIdPrefix));
                const t = vg && vg.detected ? vg.detected : null;
                // draw to canvas texture for screen
                if (!h.canvas) {
                    h.canvas = document.createElement('canvas'); h.canvas.width = 256; h.canvas.height = 160; h.ctx = h.canvas.getContext('2d');
                    h.tex = new THREE.CanvasTexture(h.canvas);
                    h.tex.anisotropy = 4;
                    h.screen.material.map = h.tex;
                    h.screen.material.color.set(0xffffff);
                    h.screen.material.needsUpdate = true;
                }
                const ctx = h.ctx; const c = h.canvas;
                // High-contrast black background with subtle border
                ctx.fillStyle = '#000000'; ctx.fillRect(0, 0, c.width, c.height);
                ctx.strokeStyle = '#555555'; ctx.lineWidth = 2; ctx.strokeRect(1, 1, c.width - 2, c.height - 2);
                ctx.fillStyle = '#ffffff'; ctx.font = 'bold 14px sans-serif'; ctx.fillText('Vision Readout', 10, 20);
                ctx.fillStyle = '#ffffff'; ctx.font = 'bold 16px monospace';
                ctx.fillText('Piece:', 10, 50);
                ctx.fillText(t ? (t.pieceID || '') : '(none)', 80, 50);
                ctx.font = '12px monospace'; ctx.fillStyle = '#ffffff';
                ctx.fillText('Order: ' + (t ? (t.orderID || '') : ''), 10, 75);
                ctx.fillText('Type : ' + (t ? (t.type || '') : ''), 10, 95);
                ctx.fillText('Start: ' + (t ? (t.start_timestamp || '') : ''), 10, 115);
                h.tex.needsUpdate = true;
            }
            updateHMIScreen('hmiA', 'vgA_');
            updateHMIScreen('hmiB', 'vgB_');
            updateHMIScreen('hmiC', 'vgC_');

            // (Top panel removed)

            // Drive stack light: red=FAIL, green=PASS, yellow=waiting
            if (objs.qcStation && objs.qcStation.segR) {
                const pass = state.qc01.last;
                const r = objs.qcStation.segR.material; const y = objs.qcStation.segY.material; const g = objs.qcStation.segG.material;
                const off = 0.2;
                r.color.set(pass === false ? 0xff4d4f : (off * 0x010101));
                y.color.set(pass === null ? 0xf5d76e : (off * 0x010101));
                g.color.set(pass === true ? 0x57d38c : (off * 0x010101));
                r.opacity = (pass === false) ? 1.0 : 0.3;
                y.opacity = (pass === null) ? 1.0 : 0.3;
                g.opacity = (pass === true) ? 1.0 : 0.3;
                r.transparent = y.transparent = g.transparent = true;
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // Procedural item models
        function roundedRectShape(w, h, r = 0.08) {
            const s = new THREE.Shape();
            const hw = w / 2, hh = h / 2, rr = Math.min(r, hw, hh);
            s.moveTo(-hw + rr, -hh);
            s.lineTo(hw - rr, -hh);
            s.quadraticCurveTo(hw, -hh, hw, -hh + rr);
            s.lineTo(hw, hh - rr);
            s.quadraticCurveTo(hw, hh, hw - rr, hh);
            s.lineTo(-hw + rr, hh);
            s.quadraticCurveTo(-hw, hh, -hw, hh - rr);
            s.lineTo(-hw, -hh + rr);
            s.quadraticCurveTo(-hw, -hh, -hw + rr, -hh);
            return s;
        }

        function makeCrate(size) {
            const height = size;
            const w = size, d = size;
            const shape = roundedRectShape(w, d, size * 0.08);
            const geo = new THREE.ExtrudeGeometry(shape, { depth: height, bevelEnabled: false, curveSegments: 8, steps: 1 });
            geo.rotateX(-Math.PI / 2); // depth -> Y
            geo.center();
            const mat = new THREE.MeshStandardMaterial({ color: 0x8ea3b7, metalness: 0.05, roughness: 0.85 });
            const crate = new THREE.Mesh(geo, mat);
            // flush top cap (slight inset) for a more finished look
            const capMat = new THREE.MeshStandardMaterial({ color: 0x7b8ba0, metalness: 0.08, roughness: 0.7 });
            const cap = new THREE.Mesh(new THREE.PlaneGeometry(w * 0.96, d * 0.96), capMat);
            cap.rotation.x = -Math.PI / 2; cap.position.y = height / 2 + 0.001;
            const group = new THREE.Group();
            group.add(crate, cap);
            group.userData.dim = { height };
            return group;
        }

        function makeBarrel(size) {
            const height = size;
            // Make the barrel wide enough to comfortably fit the QR (0.7*size square => ~0.99*size diagonal, so r >= ~0.5*size)
            const rBase = size * 0.52; // broader top for QR
            const bulge = rBase * 0.06; // subtle bulge
            const pts = [];
            const steps = 12;
            for (let i = 0; i <= steps; i++) {
                const y = (i / steps) * height - height / 2; // -h/2..h/2
                const t = i / steps;
                const radius = rBase + bulge * Math.sin(Math.PI * t);
                pts.push(new THREE.Vector2(radius, y));
            }
            const geo = new THREE.LatheGeometry(pts, 32);
            const mat = new THREE.MeshStandardMaterial({ color: 0xaab3c0, metalness: 0.08, roughness: 0.8 });
            const barrel = new THREE.Mesh(geo, mat);
            // Top cap so it's not transparent
            const capMat = new THREE.MeshStandardMaterial({ color: 0x9aa4b2, metalness: 0.1, roughness: 0.75, side: THREE.DoubleSide });
            const topCap = new THREE.Mesh(new THREE.CircleGeometry(rBase * 0.985, 48), capMat);
            topCap.rotation.x = -Math.PI / 2;
            topCap.position.y = height / 2 + 0.0005;
            // Hoops
            const hoopMat = new THREE.MeshStandardMaterial({ color: 0x6c7688, metalness: 0.3, roughness: 0.4 });
            const hoops = new THREE.Group();
            const hoopR = rBase + bulge + 0.002;
            [-0.32, 0.0, 0.32].forEach(pos => {
                const tGeo = new THREE.TorusGeometry(hoopR, 0.006, 8, 56);
                const tMesh = new THREE.Mesh(tGeo, hoopMat);
                tMesh.rotation.x = Math.PI / 2;
                tMesh.position.y = pos * height;
                hoops.add(tMesh);
            });
            const group = new THREE.Group();
            group.add(barrel, topCap, hoops);
            group.userData.dim = { height };
            return group;
        }

        // Production line: items moving on belts with QC routing
        let itemSeq = 0; let spawnAcc = 0; let spawnAlt = false;
        function spawnItem() {
            // honor production order filters
            const po = state.production || { filters: { box: true, cylinder: true }, largeOnly: false };
            const allowBox = !!po.filters.box;
            const allowCyl = !!po.filters.cylinder;
            if (!allowBox && !allowCyl) { return false; }
            const isCylinder = allowBox && allowCyl ? (spawnAlt = !spawnAlt) : (allowCyl ? true : false);
            const minS = po.largeOnly ? 0.46 : 0.32;
            const maxS = po.largeOnly ? 0.62 : 0.46;
            const size = minS + Math.random() * (maxS - minS);

            const mesh = isCylinder ? makeBarrel(size) : makeCrate(size);
            objs.itemsGroup && objs.itemsGroup.add(mesh);
            const uid = genItemId(po.orderId);
            const startTs = nowISO();
            const sizeClass = size >= 0.42 ? 'large' : 'small';
            const shapeName = isCylinder ? 'cylinder' : 'box';
            const tag = { pieceID: uid, orderID: po.orderId || '', type: `${sizeClass}_${shapeName}`, start_timestamp: startTs };
            // NOTE: Do not add QR at spawn; it will be applied at the QR station on belt A
            const colorClone = new THREE.Color();
            if (mesh.children[0] && mesh.children[0].material && mesh.children[0].material.color) {
                colorClone.copy(mesh.children[0].material.color);
            } else {
                colorClone.set(0x9ec9ff);
            }
            const it = { id: uid, seq: 'itm' + (itemSeq++), poId: po.orderId || null, shape: isCylinder ? 'cyl' : 'box', beltId: 'beltA', s: 0, size, height: size, color: colorClone, good: null, evaluated: false, mesh, tag };
            state.line.items.push(it);
            state.line.counts.produced++;
            return true;
        }

        function posOnBelt(belt, s, item = null) {
            const p = belt.start.clone().add(belt.dir.clone().multiplyScalar(belt.length * s));
            // Belt surface approx height: detailed top ~0.72-0.76; we used 0.7 base + 0.02 beltSurf offset + 0.06/2
            const beltTop = 0.7 + 0.02 + 0.03; // 0.75
            let halfH = 0.15; // default fallback
            if (item) { halfH = (item.height ? item.height / 2 : (item.size ? item.size / 2 : halfH)); }
            p.y = beltTop + halfH + 0.001; // small epsilon to avoid z-fight
            return p;
        }

        function updateLine(dt) {
            if (!state.running || state.emergency) return;
            const belts = state.line.belts || {};
            const main = belts['beltA'];
            if (!main) return;
            // map conveyor speed to belts
            const sp = state.conveyor01.speedActual; // m/s approx
            Object.values(belts).forEach(b => b.speed = sp * (b.id === 'beltA' ? 1.0 : 0.8));
            // spawn cadence proportional to speed
            spawnAcc += dt * sp;
            if (sp > 0.05 && spawnAcc > 1.2) { spawnAcc = 0; spawnItem(); }

            const items = state.line.items;
            for (let i = items.length - 1; i >= 0; i--) {
                const it = items[i];
                const b = belts[it.beltId];
                if (!b) { items.splice(i, 1); continue; }
                const v = b.speed;
                it.s += (v * dt) / Math.max(0.1, b.length);
                // Apply QR at the Labelling station on belt A (at ~1/3)
                if (it.beltId === 'beltA' && objs.labelStationA && !it.qrApplied) {
                    if (Math.abs(it.s - objs.labelStationA.sPos) < 0.02) {
                        try {
                            const qrTex = makeQRTexture(JSON.stringify(it.tag), 256);
                            const qrSize = it.size * 0.7;
                            const qrPlane = new THREE.Mesh(
                                new THREE.PlaneGeometry(qrSize, qrSize),
                                new THREE.MeshBasicMaterial({ map: qrTex, transparent: true, depthWrite: false })
                            );
                            const h = it.height || it.size;
                            qrPlane.position.set(0, h / 2 + 0.002, 0);
                            qrPlane.rotation.x = -Math.PI / 2;
                            it.mesh.add(qrPlane);
                            it.qrApplied = true;
                            // Publish applied QR payload to MQTT
                            const payload = Object.assign({ station: 'label01', applied_timestamp: nowISO() }, it.tag || {});
                            publishBundle(topic('production', 'label01', 'events', 'applied'), payload);
                        } catch { }
                    }
                }

                // Evaluate quality earlier under QC gantry, but do not move diverter yet
                // Evaluate quality near the intersection (end of beltA)
                if (it.s >= 0.90 && it.beltId === 'beltA' && !it.evaluated) {
                    const pass = Math.random() < state.qc01.passRate;
                    it.good = pass; it.evaluated = true; state.qc01.last = pass; state.qc01.lastId = it.id; syncUI();
                }
                // Arm diverter only when the evaluated item is about to touch it
                if (it.beltId === 'beltA' && it.evaluated && !it.gateSet && it.s >= 0.92) {
                    // correct pass/fail swing: pass -> +Z branch, fail -> -Z branch
                    if (objs.diverter) objs.diverter.targetAngle = it.good ? -0.6 : 0.6;
                    it.gateSet = true;
                }
                if (it.s >= 1.0) {
                    if (it.beltId === 'beltA') {
                        const next = it.good ? b.nextPass : b.nextFail;
                        if (next) { it.beltId = next; it.s = 0; if (objs.diverter) objs.diverter.targetAngle = 0; continue; }
                    }
                    // reached end/bins
                    objs.itemsGroup && objs.itemsGroup.remove(it.mesh);
                    items.splice(i, 1);
                    if (it.good) state.line.counts.passed++; else state.line.counts.rejected++;
                    syncUI();
                    continue;
                }
                // update mesh transform
                const pos = posOnBelt(b, clamp(it.s, 0, 0.999), it);
                it.mesh.position.copy(pos);
                // find a primary child mesh to color (first mesh with a material)
                let targetMesh = null;
                if (it.mesh) {
                    if (it.mesh.isMesh && it.mesh.material) targetMesh = it.mesh;
                    else targetMesh = it.mesh.children.find(c => c.isMesh && c.material) || null;
                }
                if (targetMesh && targetMesh.material && targetMesh.material.color) {
                    if (it.good === null) targetMesh.material.color.copy(it.color);
                    else targetMesh.material.color.set(it.good ? 0x57d38c : 0xff4d4f);
                }
            }

            // Update photoeyes
            if (state.line.photoeyes && state.line.photoeyes.length) {
                const widthTol = 0.6; // how tightly along the crossing we test
                for (const pe of state.line.photoeyes) {
                    const belt = belts[pe.beltId]; if (!belt) continue;
                    // find any item on same belt whose s near sensor sPos
                    let blocked = 0;
                    for (const it of items) {
                        if (it.beltId !== pe.beltId) continue;
                        if (Math.abs(it.s - pe.sPos) < 0.06) { blocked = 1; break; }
                    }
                    pe.blocked = blocked;
                    if (pe.beam) pe.beam.visible = blocked ? false : true;
                }
            }

            // Vision reads: if an item is under the gate (within window), report its tag payload
            if (state.line.vision && state.line.vision.length) {
                for (const vg of state.line.vision) {
                    const belt = belts[vg.beltId]; if (!belt) continue;
                    vg.detected = null;
                    for (const it of items) {
                        if (it.beltId !== vg.beltId) continue;
                        if (Math.abs(it.s - vg.sPos) < 0.03) { vg.detected = it.tag || null; break; }
                    }
                }
            }
        }

        // UI events
        $('#btnConnect').addEventListener('click', () => {
            // Don't allow clicking while connecting
            if (state.connecting) return;

            cfg.mqtt.url = $('#mqttUrl').value || cfg.mqtt.url;
            cfg.mqtt.user = $('#mqttUser').value;
            cfg.mqtt.pass = $('#mqttPass').value;
            // Preserve randomized default if the input is empty
            cfg.baseTopic = $('#baseTopic').value || cfg.baseTopic;
            cfg.qos = Number($('#qos').value) || 1;
            // publish interval setting removed
            if (state.connected && state.client) {
                try { state.client.end(true); } catch (e) { }
                state.client = null;
                state.connected = false;
                syncUI();
                log('MQTT disconnected by user');
            } else {
                connectMQTT();
            }
        });

        $('#btnRun').addEventListener('click', () => { state.running = true; log('Simulation started'); });
        $('#btnPause').addEventListener('click', () => { state.running = false; log('Simulation paused'); });
        $('#btnEStop').addEventListener('click', () => { state.emergency = !state.emergency; log('E-STOP ' + (state.emergency ? 'ENGAGED' : 'CLEARED')); });

        $('#convSpeed').addEventListener('input', (e) => {
            state.conveyor01.speedSet = Number(e.target.value);
            if (state.connected) {
                publish(topic('production', 'conveyor01', 'actuators', 'speed_setpoint'), message(state.conveyor01.speedSet, 'm/s'));
            }
        });
        $('#convStart').addEventListener('click', () => { state.conveyor01.enabled = true; log('Conveyor01 started'); });
        $('#convStop').addEventListener('click', () => { state.conveyor01.enabled = false; log('Conveyor01 stopped'); });

        // removed tank/pump/history handlers

        // QC rate
        $('#qcRate').addEventListener('input', (e) => { state.qc01.passRate = Number(e.target.value); syncUI(); });

        // Production Order submit
        document.getElementById('poSubmit').addEventListener('click', () => {
            const id = (document.getElementById('poId').value || '').trim();
            const box = !!document.getElementById('poBox').checked;
            const cyl = !!document.getElementById('poCyl').checked;
            const large = !!document.getElementById('poLarge').checked;
            state.production.orderId = id || state.production.orderId;
            state.production.filters.box = box;
            state.production.filters.cylinder = cyl;
            state.production.largeOnly = large;
            log(`Production order set: id=${state.production.orderId}, box=${box}, cylinder=${cyl}, largeOnly=${large}`);
            syncProductionUI(true);
            syncUI();
        });

        // Init (autonomous)
        setup3D();
        setupCollapsibles();
        setupSidebarToggle();
        state.conveyor01.enabled = true;
        state.conveyor01.speedSet = 1.0;
        // no pump/tank in simplified layout
        // Do not auto-connect to MQTT; use the Connect button
        state.running = true;
        syncUI();
        syncProductionUI(true);
        requestAnimationFrame(tick);
    </script>
</body>

</html>